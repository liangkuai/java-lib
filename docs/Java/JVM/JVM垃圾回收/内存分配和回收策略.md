# 内存分配与回收策略

***JVM 的自动内存管理主要是为了解决两个问题：分配内存和和回收内存。*** 前面已经详细讲了如何回收内存，接下来学习存一些基本的内存分配原则。


### 对象优先在 Eden 区域分配

**大多数情况下，对象在新生代的 Eden 区分配（少数情况下，大对象直接分配在老年代）。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。**

- 如果在 Minor GC 期间发现 To Survivor 区不足以容纳 Eden  + From Survivor 内的存活对象时，那就只能通过「分配担保机制」把新生代的对象提前转移到老年代。

> HotSpot 虚拟机提供了参数 `-XX:+PrintGCDetails` 用来打印 GC 日志，并且在进程退出时打印当前各个内存区域的分配情况。


### 大对象直接进入老年代

所谓的大对象是指需要大量连续内存空间的 Java 对象，比如；长字符串和大数组。

这条策略的目的是避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制（新生代 GC 都是采用复制算法）。

> HotSpot 虚拟机提供参数 `-XX:PretenureSizeThreshold`，大于这个参数设置值的对象直接在老年代分配。
>
> `-XX:PretenureSizeThreshold` 这个参数只对 Serial 和 ParNew 两款垃圾回收器有效。


### 长期存活的对象将进入老年代

HotSpot 虚拟机采用分代回收来管理堆内存，那内存回收时就必须觉得哪些存活对象应该放在新生代，哪些存活对象应该放在老年代。为了做到这点，虚拟机给每个对象定义一个对象年龄（Age）计数器。

- 对象在 Eden 出生，如果经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。
- 对象在 Survivor 中每经历一次 Minor GC，年龄就加 1，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。

> HotSpot 虚拟机提供参数 `-XX:MaxTenuringThreshold` 用来设置对象晋升到老年代的年龄阈值。


### 动态对象年龄判定

为了能更好的适应不同程序的内存状况，HotSpot 虚拟机并不是一定要求对象的年龄必须达到 `-XX:MaxTenuringThreshold` 才能晋升老年代。

如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，不需要等到 `-XX:MaxTenuringThreshold` 设置的年龄。


### 空间分配担保

在发生 Minor GC 之前，只要老年代最大可用的连续空间大于新生代所有对象总空间或者历次晋升到老年代对象的平均大小，就进行 Mnior GC，否则进行 Full GC。