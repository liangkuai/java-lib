# 锁优化

对象监视器（monitor）是依赖于操作系统的 Mutex Lock 来实现的，（在主流 JVM 实现中，Java 的线程是 1:1 映射到内核线程上的）如果要挂起或唤醒一个线程，就需要从用户态转换为内核态，进行这种状态转换需要耗费很多处理器时间。所以在 JDK 1.6 之前 **`synchronized` 提供的互斥同步是一个重量级的操作。**

在 JDK 1.6 中，HotSpot 虚拟机对 `synchronized` 实现了各种锁优化技术来提高效率。


### 自旋锁与自适应自旋

在互斥同步中，挂起或恢复线程都需要转入内核态中完成，这些操作给 JVM 的并发性能带来了很大的压力。但是许多应用上，共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得。我们可以让后面请求锁的线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。

**为了让线程等待，我们只须让线程执行一个忙循环（自旋），这就是自旋锁。**

> HotSpot 虚拟机提供参数 `-XX:+UseSpinning` 来开启自旋锁。自旋锁在 JDK 1.4.2 中就已经引入，只不过默认是关闭的，在 JDK 6 中就已经改为默认开启了。

自旋等待不能代替阻塞，虽然避免了线程切换的开销，但是自旋等待的线程是要占用处理器时间的，所以如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。

**因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。**

> HotSpot 虚拟机提供参数 `-XX:PreBlockSpin` 用来设置自旋锁次数，默认 10 次。

#### 自适应自旋
无论是默认值还是用户指定的自旋次数，对整个 JVM 中所有的锁来说都是相同的。

在 JDK 6 中对自旋锁的优化，引入了自适应的自旋。**自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。**

如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续 100 次忙循环。而如果对于某个锁，自旋很少成功获得过锁，那在以后要获得这个锁时将有可能直接省略掉自旋过程，避免浪费处理器资源。


---
### 轻量级锁

轻量级锁是 JDK 1.6 加入的新型锁机制，所谓 “轻量级” 是相对于使用操作系统互斥量来实现的重量级锁而言。**轻量级锁并不是用来代替重量级锁的，设计的目的是在没有多线程竞争的前提下，减少重量级锁产生的性能消耗。**

要理解轻量级锁，以及后面会讲到的偏向锁的原理和运作过程，必须先了解 [HotSpot 虚拟机的对象在内存中存储的内容](/docs/Java/JVM/HotSpot中的对象.md)。

#### 加锁
1. 在进入同步块时，如果同步对象处于无锁状态（锁标志位：01，偏向锁标志位：0），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 拷贝（官方称为 Displaced Mark Word）。

2. 将同步对象的 Mark Word 拷贝到锁记录中。

3. 虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向同步对象。

4. 如果更新成功，那么这个线程就拥有了该同步对象的锁，并且对象的 Mark Word 的锁标志位更新为 00，表示此对象处于轻量级锁定状态。

5. 如果更新失败，虚拟机会首先检查同步对象的 Mark Word 是否指向当前线程的栈帧。
    - 如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行；
    - 否则说明这个同步对象已经被其他线程抢占了。
    
如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志位变为 10，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。

#### 解锁
1. 通过 CAS 操作把同步对象当前的 Mark Word 和线程中的 Displaced Mark Word 替换回来。

2. 如果替换成功，整个同步过程结束。

3. 如果替换失败，说明其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。

#### 总结
轻量级锁能提升同步性能的依据是 ”对于绝大部分的锁，在整个同步周期内都是不存在竞争的“，这是一个经验。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外执行了 CAS 操作，因此在有竞争力的情况下，轻量级锁会比传统的重量级锁更慢。


---
### 偏向锁

偏向锁是 JDK 1.6 引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语，进一步提高性能。**如果说轻量级锁是在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都取消掉，连 CAS 操作都不做了。**

所谓偏向锁，就是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，这个锁没有被其他的线程获取，那么持有偏向锁的线程将永远不需要再进行同步。

> HotSpot 虚拟机提供参数 `-XX:+UseBiasedLocking` 启用偏向锁，JDK 1.6 开始默认启用。

#### 加锁
![偏向锁](/assets/images/JVM/偏向锁.jpg)

#### 解锁
**持有偏向锁的线程不会主动释放锁**，当有另一个线程去尝试获取这个锁时，就会退出偏向模式。将根据原持有偏向锁的线程的状态，撤销偏向后恢复到未锁定或轻量级锁定的状态，然后执行后续的同步操作。

#### 总结
偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。

在具体问题具体分析的情况下，有时候使用参数 `-XX:-UseBiasedLocking` 来禁止偏向优化反而可以提升性能。



---
### 其他优化

#### 锁消除
锁消除指的是虚拟机即时编译器在运行时，对一些代码上有同步，但是实际检测到不可能存在共享数据竞争的锁进行消除。

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当做栈上数据对待，认为是线程私有，也就不需要加锁同步。

例如，多个字符串相加连接：在 JDK 1.5 之前，Javac 编译器会对 String 连接做自动优化，会转化为 `StringBuffer` 对象的连续 `append()` 操作，但是 `StringBuffer` 类的 `append()` 方法是同步方法，实际没有必要进行同步，最后锁会被安全地消除掉。

#### 锁粗化
原则上，我们在写代码时应该让同步块的范围尽量小，如：懒汉式单例模式。但是如果一系列的连续操作都对同一个对象反复加解锁，甚至加锁操作是在循环体中，那么就算没有线程竞争，频繁的同步操作会导致不必要的性能损耗。

例如，使用 `StringBuffer` 对象连续 append，编译器会把同步块扩展到整个操作（粗化）。