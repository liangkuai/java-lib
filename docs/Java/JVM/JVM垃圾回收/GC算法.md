# GC 算法

### 分代收集理论

当前商业虚拟机的垃圾回收器，大多数都遵循了「分代收集」（Generational Collection）的理论进行设计。所谓的分代收集理论其实是一系列符合大多数程序实际运行情况的经验。

> - 绝大多数对象都是朝生夕灭
> - 经历过越多次 GC 的对象就越难以消亡

根据以上两条实践经验，得出了多种垃圾回收器的设计原则：**垃圾回收器应该将 Java 堆划分为不同的区域，然后将回收对象根据年龄分配到不同的区域存储。**

显而易见，

- 如果一个区域中大多数对象存活时间很短，那么把它们放到一起，每次回收只关注如何保留少量存活的对象，这样就能以较低的代价回收到大量的内存空间。
- 类似的，如果一个区域都是存活时间长的对象，那么把它们放到一起，虚拟机就可以用较低的频率来回收，这样既减少了 GC 的时间开销又有效的利用了内存空间。


---
### 标记-清除算法（Mark-Sweep）

标记-清除算法是最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。

#### 核心
算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

#### 缺点
- 效率低：可回收的对象越多，执行效率就越低。
- 内存碎片：标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致后面需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次 GC。


---
### 标记-复制算法

#### 核心
将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块去，然后把这一块已使用的内存空间一次清理掉。

#### 适用场景
如果内存中多数对象都是存活的，那么就会产生大量的内存间复制的开销。但是**对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象。**

这样每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。实现简单，运行高效。

**现在的商用 JVM 大多都优先采用这种算法来回收新生代。**

#### 缺点
- 浪费内存


---
### 标记-整理算法（Mark-Compact）

#### 核心
标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清除，而是让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存。

#### 缺点
- 需要移动回收后存活的对象

#### 与「标记-清除」算法比较
对于「标记-整理」算法来说，如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动存活对象并更新所有引用这些对象的地方是一个消耗很大的操作，而且这种对象移动操作必须全程暂停用户线程才能进行（Stop The World）。

当然，「标记-清除」算法通常也需要暂停用户线程来标记、清除可回收对象，但暂停时间相对来说要短。

「标记-清除」算法不考虑移动和整理存活对象，那么内存碎片问题只能依赖更复杂的内存分配器和内存访问器来解决。但是内存的访问是最频繁的操作，如果在这个环节上增加了额外的负担，肯定会直接影响应用程序的吞吐量。

**所以是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。**

- 从 GC 的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿。
- 从整个程序的吞吐量来看，移动对象会更划算。

即使不移动对象会使得垃圾回收器的效率提升一些，但是因为内存分配和访问相比 GC 的频率要高很多，这部分的耗时增加，总吞吐量仍然是下降的。

HotSpot VM 中，关注吞吐量的 Parallel Scavenge 回收器是基于「标记-整理」算法的，而关注延迟的 CMS 回收器是基于「标记-清除」算法的。

除此之外，还有一种综合的解决方案，可以不在内存分配和访问上增加太大额外负担，
- 让虚拟机平时多数时间采用「标记-清除」算法，暂时容忍内存碎片的存在，
- 直到内存空间的碎片化程度已经达到影响对象分配时，再采用「标记-整理」算法收集一次，来获得规整的内存空间。（基于「标记-清除」算法的 CMS 回收器面临内存碎片过多时采用的就是这种处理办法）