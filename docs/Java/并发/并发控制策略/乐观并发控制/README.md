# 乐观并发控制

总是假设最好的情况。也就是说，即使在并发环境下，也认为各个线程对共享数据的操作是同步执行（虽然实际不是），不需要加锁控制。

当前线程先获取一份共享数据的拷贝 A；然后在执行完逻辑之后，尝试将修改后的值 B 写入共享数据的实际存储空间；但是在写入之前，先检查一下共享数据的值还是不是 A。如果是，那就说明共享数据没有被修改，可以将共享数据的值改为 B；如果不是，那就说明共享数据一定被其他线程修改过，那么就要采取其他补偿措施。

通俗地说，就是先执行逻辑，执行完之后就尝试写入，如果没有其他线程争用共享资源，那操作成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见就是自旋）。

#### 实现方式

- 版本号机制
- CAS

#### 适用场景

乐观并发控制适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。