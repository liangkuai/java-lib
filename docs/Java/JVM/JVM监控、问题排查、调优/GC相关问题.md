# GC 相关问题

不管是哪种 GC，都会造成一定的程序卡段（Stop The World），即使是 CMS、G1 这些先进的垃圾回收器，也只是在减少卡顿时间，而不能完全消除。

以下是 GC 产生的影响，程度从高到低，

1. **Full GC 过于频繁**：Full GC 通常比较慢，少则几百毫秒，多则几秒。正常情况下，每隔几个小时甚至几天才执行一次 Full GC，对系统的影响还能接受。但是，**一旦 Full GC 频繁，会导致工作线程频繁被停止，服务超时，程序整体性能下降。**

2. **Young GC 耗时过长**：一般来说，Young GC 耗时在几十毫秒或者上百毫秒，引起的系统卡顿影响几乎可以忽略不计。**但是如果 Young GC 耗时过长，就会导致服务超时。**

3. **Full GC 耗时过长**

4. **Young GC 过于频繁**


### Young GC 问题排查

#### 1. 前置措施
- 检查监控，确定 GC 的频率和时长；
- 保留现场，
    - 打印 JVM 参数
    - 用 `jmap` dump 堆转储快照，最好先把进行 dump 的那台机器下掉（可以通过配置 VM 参数 `-XX:+HeapDumpOnOutOfMemoryError` 获取）；
- 重启机器或回滚代码。

#### 2. 检查监控
- 检查监控，确定 GC 的频率和时长；
- 根据 Young GC 的过程，结合监控进行分析

> Young GC 的过程：
> 1. 从 GC Root 扫描对象，对存活对象进行标记；
> 2. 将存活对象复制到 To Survivor，或者晋升到老年代。

- 判断 Young GC 前后新生代各个区的内存变化；
    - 如果 Young GC 之后，Survivor 使用率增高，说明生命周期长的对象越来越多，导致标记和复制过程的耗时增加。
    - 如果没什么大的变化，说明频繁创建大量对象，导致频繁 Young GC。

#### 3. 分析 heapdump 文件
- 使用 MAT 工具导入 dump 文件；
- 通过 Dominator Tree 查看当前堆中，占用内存大的类和对象，再结合代码分析。




### 参考
- [排查YGC问题 - IT人的职场进阶 - 微信公众号](https://mp.weixin.qq.com/s/O0l-d928hr994OpSNw3oow)