# 锁优化

对象监视器（monitor）是依赖于操作系统的 Mutex Lock 来实现的，（在主流 JVM 实现中，Java 的线程是 1:1 映射到内核线程上的）如果要挂起或唤醒一个线程，就需要从用户态转换为内核态，进行这种状态转换需要耗费很多处理器时间。所以在 JDK 1.6 之前 **`synchronized` 提供的互斥同步是一个重量级的操作。**

在 JDK 1.6 中，HotSpot 虚拟机对 `synchronized` 实现了各种锁优化技术来提高效率。


### 自旋锁与自适应自旋

在互斥同步中，挂起或恢复线程都需要转入内核态中完成，这些操作给 JVM 的并发性能带来了很大的压力。但是许多应用上，共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得。我们可以让后面请求锁的线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。

**为了让线程等待，我们只须让线程执行一个忙循环（自旋），这就是自旋锁。**

> HotSpot 虚拟机提供参数 `-XX:+UseSpinning` 来开启自旋锁。自旋锁在 JDK 1.4.2 中就已经引入，只不过默认是关闭的，在 JDK 6 中就已经改为默认开启了。

自旋等待不能代替阻塞，虽然避免了线程切换的开销，但是自旋等待的线程是要占用处理器时间的，所以如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有价值的工作，这就会带来性能的浪费。

**因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。**

> HotSpot 虚拟机提供参数 `-XX:PreBlockSpin` 用来设置自旋锁次数，默认 10 次。

#### 自适应自旋
无论是默认值还是用户指定的自旋次数，对整个 JVM 中所有的锁来说都是相同的。

在 JDK 6 中对自旋锁的优化，引入了自适应的自旋。**自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。**

如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续 100 次忙循环。而如果对于某个锁，自旋很少成功获得过锁，那在以后要获得这个锁时将有可能直接省略掉自旋过程，避免浪费处理器资源。


### 轻量级锁

轻量级锁是 JDK 1.6 加入的新型锁机制，所谓 “轻量级” 是相对于使用操作系统互斥量来实现的重量级锁而言。**轻量级锁并不是用来代替重量级锁的，设计的目的是在没有多线程竞争的前提下，减少重量级锁产生的性能消耗。**




### 偏向锁






### 其他优化

#### 锁消除
锁消除指的是虚拟机即时编译器在运行时，对一些代码上有同步，但是实际检测到不可能存在共享数据竞争的锁进行消除。

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当做栈上数据对待，认为是线程私有，也就不需要加锁同步。

例如，多个字符串相加连接：在 JDK 1.5 之前，Javac 编译器会对 String 连接做自动优化，会转化为 `StringBuffer` 对象的连续 `append()` 操作，但是 `StringBuffer` 类的 `append()` 方法是同步方法，实际没有必要进行同步，最后锁会被安全地消除掉。

#### 锁粗化
原则上，我们在写代码时应该让同步块的范围尽量小，如：懒汉式单例模式。但是如果一系列的连续操作都对同一个对象反复加解锁，甚至加锁操作是在循环体中，那么就算没有线程竞争，频繁的同步操作会导致不必要的性能损耗。

例如，使用 `StringBuffer` 对象连续 append，编译器会把同步块扩展到整个操作（粗化）。