# 先行发生原则

如果 Java 内存模型中所有的**有序性**都仅仅靠 `volatile` 和 `synchronized` 来完成，那么有一些操作将会变的很繁琐，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 语言中有一个 “先行发生”（happens-before）原则。

happens-before 原则是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子解决并发环境下两个操作之间是否可能存在冲突的问题。


> #### 先行发生原则
> 指的是 Java 内存模型中定义的两项操作之间的偏序关系；
> 
> 如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，影响包括：修改了内存中共享变量的值、发送了消息、调用了方法等。


#### 1. 程序次序规则（Program Order Rule）
在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。

#### 2. 管程锁定规则（Monitor Lock Rule）
一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而 “后面” 是指时间上的先后顺序。

#### 3. volatile 变量规则（Volatile Variable Rule）
对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，这里 “后面” 同样是指时间上的先后顺序。

#### 4. 线程启动规则（Thread Start Rule）
Thread 对象的 start() 方法先行发生于此线程的每一个动作。

#### 5. 线程终止规则（Thread Termination Rule）
线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止执行。

#### 6. 线程中断规则（Thread Interruption Rule）
对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。

#### 7. 对象终结规则（Finalizer Rule）
一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。

#### 8. 传递性（Transitivity）
如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那就可以得出操作 A 先行发生于操作 C 的结论。