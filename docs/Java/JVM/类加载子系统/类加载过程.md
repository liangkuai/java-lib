# 类加载过程

- 加载
- 连接
    - 验证
    - 准备
    - 解析
- 初始化


### 加载（Loading）

1. 通过全类名获取定义该类的二进制字节流

2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构

3. 在内存中生成一个代表该类的 `java.lang.Class` 对象，作为方法区中这个类的各种数据结构的访问入口

**JVM 规范对上述加载过程定义并不具体，所以实现方式非常灵活**。比如，第一步并没有指明具体从哪里获取、怎样获取类的二进制字节流。


### 连接（Linking）

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

#### 验证（Verification）

进行验证的目的是为了确保字节流符合 JVM 的 Class 格式规范。

#### 准备（Preparation）

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

- 进行内存分配的只包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中

- 设置的初始值指的是数据类型默认的零值，但是带有 `final` 的变量在准备阶段就会赋值为声明的值。

![数据类型零值](/assets/images/JVM/数据类型零值.png)

#### 解析（Resolution）

解析阶段是将常量池内的符号引用替换为直接引用的过程。

**符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄**。在程序实际运行时，只有符号引用是不够的，例如：在程序执行方法时，系统需要明确知道这个方法所在的位置。JVM 为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。


### 初始化（Initialization）

初始化是类加载的最后一步，初始化阶段是执行**类构造器** `<clinit>()` 方法的过程。

对于 `<clinit>()` 方法的调用，JVM 会自己确保其在多线程环境中的安全性。因为 `<clinit>()` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。


#### 必须进行初始化的六种情况

对于初始化阶段，《Java 虚拟机规范》严格规定了**有且只有** 6 种情况，如果类还没有进行过初始化，必须先对类进行「初始化」：

1. 当遇到 `new`、`getstatic`、`putstatic` 或 `invokestatic` 这 4 条字节码指令时，比如：
    - new 一个对象
    - 读取或设置一个类的静态变量(未被 `final` 修饰)
    - 调用一个类的静态方法

2. 使用 `java.lang.reflect` 包的方法对类进行反射调用的时候。

3. 初始化一个类的时候，如果其父类还未初始化，就先触发该父类的初始化。

4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。

5. 当使用 JDK 1.7 的动态语言支持时，如果一个 `java.lang.invoke.MethodHandle` 实例最后的解析结果是 `REF_getStatic`、`REF_putStatic`、`REF_invokeStatic`、`REF_newInvokeSpecial` 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，就需要先触发其初始化。

6. 当一个接口中定义了 JDK 8 新加入的默认方法（被 `default` 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

