# 锁优化

对象监视器（monitor）是依赖于操作系统的 Mutex Lock 来实现的，

在主流 JVM 实现中，Java 的线程是 1:1 映射到内核线程上的，如果要阻塞或唤醒一个线程，就需要从用户态转换为内核态，进行这种状态转换需要耗费很多处理器时间。

**所以 `synchronized` 提供的互斥同步是一个重量级的操作。**



### 偏向锁







### 其他优化

#### 锁消除
虚拟机即时编译器在运行时，对一些代码上有同步，但是实际检测到不存在共享数据竞争的锁进行消除。

锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当做栈上数据对待，认为是线程私有，也就不需要加锁同步。

例如，多个字符串相加，编译器会进行优化，
- JDK 1.5 之前，会转化为 `StringBuffer` 对象的连续 append 操作；但是 `StringBuffer` 类的 `append()` 方法是同步方法，

#### 锁粗化
原则上，我们在写代码时应该让同步块的范围尽量小，但是如果同步块是在循环体中，频繁的加解锁会导致不必要的性能损耗。

例如，使用 `StringBuffer` 对象连续 append，编译器会扩展同步块（粗化）。