# 线程安全

> 当多个线程同时访问一个对象时，如果
> - 不考虑这些线程在运行时环境下的调度和交替执行，
> - 也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
>
> 调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。
>
> ——《Java 并发编程实战（Java Concurrency In Practice）》

这个定义就很严谨而且有可操作性，它要求线程安全的代码都必须具备一个共同特性：**代码本身封装了所有必要的正确性保障手段**（如互斥同步等），让调用者无须关心多线程下的调用问题，更无须自己实现任何措施来保证多线程环境下的正确调用。

在大多数场景中，我们都会将这个定义弱化一些，如果把 **「调用这个对象的行为」限定为「单次调用」**，这个定义的其他描述也能够成立的话，我们就可以称它是线程安全了。


## Java 中的线程安全

#### 1. 不可变
不可变的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再进行任何线程安全保障措施。例如 `Java.lang.String` 类的对象实例就是一个不可变对象。

Java API 中符合不可变要求的类型，除了 String 之外，常用的还有枚举类型及 `java.lang.Number` 的部分子类。

#### 2. 绝对线程安全
「绝对线程安全」能够完全满足上述给出的线程安全的定义，这个定义其实是很严格的，一个类要达到 “不管运行时环境如何，调用者都不需要任何额外的同步措施” 可能要付出非常高昂的代价。

在 Java API 中标注自己是线程安全的类，大多数都不是绝对的线程安全。例如 `java.util.Vector` 中所有方法都被 `synchronized` 修饰，但并不意味着调用的时候不再需要同步手段了（如果删除的同时打印所有元素，可能会导致并发问题）。

#### 3. 相对线程安全
「相对线程安全」就是我们通常意义上所讲的线程安全，它需要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

Java API 中大部分声称线程安全的类都属于这种类型。

#### 4. 线程兼容
「线程兼容」是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用。我们平常说一个类不是线程安全的，通常指的是这种情况。

Java API 中大部分的类都是属于线程兼容的，如：与 `Vector` 和 `HashTable` 相对应的集合类 `ArrayList` 和 `HashMap` 等。

#### 5. 线程对立   
「线程对立」指的是无论调用端是否采取了同步措施，都无法在多线程环境中并发使用代码。

由于 Java 天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。


## 线程安全的实现方式
- 互斥同步（悲观）
- 非阻塞同步
- 无同步方案

### 1. 互斥同步（阻塞同步）
互斥同步是一种悲观并发控制策略。在多线程并发访问共享数据时，保证共享数据同一时刻只被一个线程（当使用信号量时，可以是多个）使用。

具体实现：
- `synchronized` 关键字
- `ReentrantLock`

互斥同步最大的问题就是线程阻塞和唤醒所带来的性能问题，所以也被称为阻塞同步。

### 2. 非阻塞同步
非阻塞同步是一种乐观并发控制策略。通俗地说，就是先尝试执行，如果没有其他线程争用共享资源，那操作成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见就是自旋）。

### 3. 无同步方式
要保证线程安全，并不是一定就要进行同步。如果一个方法不涉及共享数据，自然就不需要同步措施。

#### 3.1 可重入代码（Reentrant Code）
可重复代码都是线程安全的。

有一个简单的原则可以判断代码是否具备可重入性：如果一个方法的返回结果是可以预测的，只要输入相同的参数，就能返回相同的结果，那就满足可重入性，同时也是线程安全的。

#### 3.2 线程本地存储（Thread Local Storage）
将共享数据的可见范围限制在同一个线程之中，这样就不需要同步了。

#### 具体实现
- `java.lang.ThreadLocal`