# 关于引用类型

JDK 1.2 之前，Java 中引用的定义很传统，如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该 reference 数据是代表某块内存、某个对象的引用。

**一个对象在这种定义下只有“被引用”或“未被引用”两种状态，但其实对于一些对象，我们希望当内存空间足够时保留，当内存空间在进行 GC 后还是不够时就可以抛弃，也就是类似于缓存一样。**

JDK 1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）。


#### 强引用（Strongly Reference）

正常情况下都是强引用，被引用的对象不会被回收。


#### 软引用（Soft Reference）

表示一些还有用，但非必须的对象。

如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收软引用对象使用的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JVM 就会把这个软引用加入到与之关联的引用队列中。


#### 弱引用（Weak Reference）

弱引用也用来表示非必须的对象，强度比软引用更弱一些。

被弱引用关联的对象只能活到下一次 GC 发生为止。当垃圾回收器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，JVM 就会把这个弱引用加入到与之关联的引用队列中。

**实例**

- `java.lang.ThreadLocal.ThreadLocalMap.Entry` 继承自 `WeakReference`


#### 虚引用（Phantom Reference）

顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会影响对象的生命周期。如果一个对象被虚引用关联，那么它就和没有任何引用一样，在任何时候都可能被 GC。

> 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被 GC 时收到一个系统通知。

虚引用与软引用和弱引用的一个区别在于：**虚引用必须和引用队列（ReferenceQueue）联合使用**。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。
