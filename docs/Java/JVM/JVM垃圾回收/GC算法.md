# GC 算法

### 分代收集理论

当前商业虚拟机的垃圾回收器，大多数都遵循了「分代收集」（Generational Collection）的理论进行设计。所谓的分代收集理论其实是一系列符合大多数程序运行实际情况的经验。

> - 绝大多数对象都是朝生夕灭
> - 经历过越多次 GC 的对象就越难以消亡

根据以上两条实践经验，得出了多种垃圾回收器的设计原则：**垃圾回收器应该将 Java 堆划分为不同的区域，然后将回收对象根据年龄分配到不同的区域存储。**

显而易见，

- 如果一个区域中大多数对象存活时间很短，那么把它们放到一起，每次回收只关注如何保留少量存活的对象。这样就能以较低的代价回收到大量的内存空间。
- 类似的，如果一个区域都是存活时间长的对象，那么把它们放到一起，虚拟机就可以用较低的频率来回收，这样既减少了 GC 的时间开销又有效的利用了内存空间。

---
### 标记-清除算法

标记-清除算法（Mark-Sweep）算法。最基础的收集算法，后续的收集算法都是基于这种思路并对其不足进行改进而得到的。

#### 核心

算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

#### 缺点
- 效率低
- 内存碎片


---
### 标记-复制算法

#### 核心

> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块去，然后把这一块已使用的内存空间一次清理掉。

这样每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。实现简单，运行高效。

#### 

#### 缺点
- 浪费内存

---
### 标记-整理算法


#### 有点
- 解决了内存碎片的问题

#### 缺点
- 频繁移动存活的对象，效率低