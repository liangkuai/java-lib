# 逃逸分析

Escape Analysis

和类型继承关系分析一样，逃逸分析并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。

### 基本原理
分析对象动态作用域，分为两种：
- 「方法逃逸」：当一个对象在方法中被定义后，它可能被外部方法所引用，例如：作为调用参数传递到其他方法中。
- 「线程逃逸」：当前线程中创建的对象被外部线程访问到，例如：赋值给可以在其他线程中访问到的实例变量。

从「不逃逸」、「方法逃逸」、「线程逃逸」，称为对象由低到高的不同逃逸程度。

如果能证明一个对象不会逃逸到方法或线程之外（也就是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，包括
- 栈上分配
- 同步消除
- 标量替换

#### 栈上分配（Stack Allocation）
在 JVM 中，几乎所有的 Java 对象实例和数组都是在堆中分配内存，只要持有这个对象的引用，就可以访问堆中存储的对象数据。垃圾回收器可以回收堆中不再使用的对象，但是回收需要耗费资源和时间。

**如果确定一个对象不会逃逸到方法之外，就可以考虑让这个对象在栈上分配内存，对象所占用的内存空间就可以随栈帧出栈而回收。**

在一般应用中，不会逃逸的局部对象所占的比例较大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁，垃圾回收器的压力就会小很多。


#### 标量替换
> - 标量：如果一个数据已经无法再分解成更小的数据来表示了，JVM 中的原始数据类型都不能再进一步分解了，那么这些数据就可以被称为标量。
>
> - 聚合量：如果一个数据可以继续分解，那么就被成为聚合量，Java 中的对象就是典型的聚合量。

**如果把一个 Java 对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为「标量替换」。**

如果逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。

将对象拆分后，除了可以让对象的成员变量在栈上分配和读写之外，还可以为后续进一步的优化手段创建条件。


#### 同步消除
线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。


### 参考
- 11.4.3 逃逸分析 - 《深入理解 Java 虚拟机（第 3 版）》