# 自旋锁

对于一般的锁，一个线程 A 在获得锁后，如果再有线程 B 试图获取锁，那么这个线程 B 将会挂起（进入阻塞状态），让出处理器执行时间。但是挂起和恢复线程的操作都需要转入内核态完成，并且线程上下文切换会带来开销。

如果多线程对锁的竞争不是很激烈，对锁的占用时间短，为了这段时间去阻塞线程并且切换线程并不值得。相反，如果让这些竞争锁的线程不阻塞，不放弃处理器的执行时间，一直循环检查锁是否可用，线程在这一过程中保持执行，处于一种忙等待的状态。这种方式就称为自旋。

> 自旋锁更像是一种锁优化技术。

### 实现

在 JDK 1.5 版本及以上的并发框架 `java.util.concurrent.atomic` 包下的类基本都是自旋锁的实现，由于原理是 CAS，所以是非阻塞的框架。


### 问题

#### 1. 循环会过多占用处理器时间
自旋锁在 JDK 1.6 中默认开启。**自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间**，因此，如果锁被占用的时间很长，自旋的线程都处于忙等状态，只会白白浪费处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。

##### 解决
自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是 10 次，用户可以使用参数 `-XX:PreBlockSpin` 来更改。

在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不在固定了， 而是由前一个在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如 100 个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略自旋过程，以避免浪费处理器资源。

#### 2. 死锁
有一个线程连续两次试图获得自旋锁（比如在递归程序中），第一次这个线程获得了该锁，当第二次试图加锁的时候，检测到锁已被占用（其实是被自己占用），那么这时，线程会一直等待自己释放该锁，而不能继续执行，这样就引起了死锁。

##### 解决
递归程序决不能在持有自旋锁时调用它自己，也决不能在递归调用时试图获得相同的自旋锁。