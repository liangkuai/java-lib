# Java 与线程

#### 关于线程

> 线程是比进程更轻量级的调度执行单位，线程的引入可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件 I/O 等），又可以独立调度（线程是 CPU 调度的基本单位）。


### 两种线程实现方式

#### 1. 内核线程

> 内核线程（Kerne-Level Thread，KLT）就是直接由操作系统内核支持的线程。
>
>这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情。
>
> 支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。

程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。

#### 2. 用户线程

用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。

用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。


### 三种线程模型
#### 1. 1:1 线程模型
轻量级进程与内核线程之间 1:1 的关系称为 1:1 线程模型。

- 特点

    由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即时有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作。

- 局限性
    - 由于是基于内核线程实现的，所以各种线程操作，如创建、析构和同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。
    - 每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此**一个系统支持轻量级进程的数量是有限的**。

#### 2. 1:N 线程模型

#### 3. N:M 线程模型


### Java 中的线程实现

在早期 Classic VM 上（JDK 1.2 之前），是基于一种被称为“绿色线程”的用户线程实现的，**但从 JDK 1.3 起，主流的商业 JVM 的线程模型普遍采用基于操作系统原生线程模型来实现，也就是 1:1 线程模型。**

在 Java 中，每个已经执行 `start()` 并且还没结束的 `java.lang.Thread` 类的实例就代表一个线程。

在 Thread 类中所有关键的方法都是声明为 `Native` 的，表示这些方法都是在操作系统提供的线程实现的基础上来实现的。

> 在 Java API 中，一个方法为什么要声明成 Native 方法？
> 1. 一般说明这个方法没有使用或者没法使用平台无关的方式来实现。
> 2. 也可能是为了执行效率而使用 Native 方法。

线程模型只对线程的并发规模和操作成本产生影响，对 Java 程序的编码和运行过程来说，这些差异都是完全透明的。